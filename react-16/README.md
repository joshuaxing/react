# React 16.12.0
[学习地址](https://www.jianshu.com/p/37d7de212df1)
### react@16之前
在 react@16 以前的版本，reconciler（现被称为 stack reconciler ）采用自顶向下递归，从根组件或 setState() 后的组件开始，更新整个子树
缺点：如果组件树不大不会有问题，但是当组件树越来越大，递归遍历的成本就越高，持续占用主线程，这样主线程上的布局、动画等周期性任务以及交互响应就无法立即得到处理，造成顿卡的视觉效果

### react@16
解决：把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行。这种策略叫做 Cooperative Scheduling
（合作式调度）

### 浏览器渲染
#### 浏览器每一帧都需要完成哪些工作？
页面是一帧一帧绘制出来的，当每秒绘制的帧数（FPS）达到 60 时，页面是流畅的，小于这个值时，用户会感觉到卡顿。
### 源码思路
1. 经过babel转义  jsx -> React.createElement(component, props, ...children) 
2. ReactDOM.render() 递归创建元素
3. 